{"version":3,"file":"ts.mjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":[],"mappings":"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"}