{"version":3,"file":"redoc.cjs","sources":["../../src/lib/redoc.ts"],"sourcesContent":["import { performance } from \"node:perf_hooks\";\nimport { Readable } from \"node:stream\";\nimport { fileURLToPath } from \"node:url\";\nimport {\n  BaseResolver,\n  bundle,\n  type Document,\n  lintDocument,\n  makeDocumentFromString,\n  type NormalizedProblem,\n  type Config as RedoclyConfig,\n  Source,\n} from \"@redocly/openapi-core\";\nimport parseJson from \"parse-json\";\nimport type { OpenAPI3 } from \"../types.js\";\nimport { debug, error, warn } from \"./utils.js\";\n\nexport interface ValidateAndBundleOptions {\n  redoc: RedoclyConfig;\n  silent: boolean;\n  cwd?: URL;\n}\n\ninterface ParseSchemaOptions {\n  absoluteRef: string;\n  resolver: BaseResolver;\n}\n\nexport async function parseSchema(schema: unknown, { absoluteRef, resolver }: ParseSchemaOptions): Promise<Document> {\n  if (!schema) {\n    throw new Error(\"Canâ€™t parse empty schema\");\n  }\n  if (schema instanceof URL) {\n    const result = await resolver.resolveDocument(null, absoluteRef, true);\n    if (\"parsed\" in result) {\n      return result;\n    }\n    throw result.originalError;\n  }\n  if (schema instanceof Readable) {\n    const contents = await new Promise<string>((resolve) => {\n      schema.resume();\n      schema.setEncoding(\"utf8\");\n      let content = \"\";\n      schema.on(\"data\", (chunk: string) => {\n        content += chunk;\n      });\n      schema.on(\"end\", () => {\n        resolve(content.trim());\n      });\n    });\n    return parseSchema(contents, { absoluteRef, resolver });\n  }\n  if (schema instanceof Buffer) {\n    return parseSchema(schema.toString(\"utf8\"), { absoluteRef, resolver });\n  }\n  if (typeof schema === \"string\") {\n    // URL\n    if (schema.startsWith(\"http://\") || schema.startsWith(\"https://\") || schema.startsWith(\"file://\")) {\n      const url = new URL(schema);\n      return parseSchema(url, {\n        absoluteRef: url.protocol === \"file:\" ? fileURLToPath(url) : url.href,\n        resolver,\n      });\n    }\n    // JSON\n    if (schema[0] === \"{\") {\n      return {\n        source: new Source(absoluteRef, schema, \"application/json\"),\n        parsed: parseJson(schema),\n      };\n    }\n    // YAML\n    return makeDocumentFromString(schema, absoluteRef);\n  }\n  if (typeof schema === \"object\" && !Array.isArray(schema)) {\n    return {\n      source: new Source(absoluteRef, JSON.stringify(schema), \"application/json\"),\n      parsed: schema,\n    };\n  }\n  throw new Error(`Expected string, object, or Buffer. Got ${Array.isArray(schema) ? \"Array\" : typeof schema}`);\n}\n\nfunction _processProblems(problems: NormalizedProblem[], options: { silent: boolean }) {\n  if (problems.length) {\n    let errorMessage: string | undefined = undefined;\n    for (const problem of problems) {\n      const problemLocation = problem.location?.[0].pointer;\n      const problemMessage = problemLocation ? `${problem.message} at ${problemLocation}` : problem.message;\n      if (problem.severity === \"error\") {\n        errorMessage = problemMessage;\n        error(problemMessage);\n      } else {\n        warn(problemMessage, options.silent);\n      }\n    }\n    if (errorMessage) {\n      throw new Error(errorMessage);\n    }\n  }\n}\n\n/**\n * Validate an OpenAPI schema and flatten into a single schema using Redocly CLI\n */\nexport async function validateAndBundle(\n  source: string | URL | OpenAPI3 | Readable | Buffer,\n  options: ValidateAndBundleOptions,\n) {\n  const redocConfigT = performance.now();\n  debug(\"Loaded Redoc config\", \"redoc\", performance.now() - redocConfigT);\n  const redocParseT = performance.now();\n  let absoluteRef = fileURLToPath(new URL(options?.cwd ?? `file://${process.cwd()}/`));\n  if (source instanceof URL) {\n    absoluteRef = source.protocol === \"file:\" ? fileURLToPath(source) : source.href;\n  }\n  const resolver = new BaseResolver(options.redoc.resolve);\n  const document = await parseSchema(source, {\n    absoluteRef,\n    resolver,\n  });\n  debug(\"Parsed schema\", \"redoc\", performance.now() - redocParseT);\n\n  // 1. check for OpenAPI 3 or greater\n  const openapiVersion = Number.parseFloat(document.parsed.openapi);\n  if (\n    document.parsed.swagger ||\n    !document.parsed.openapi ||\n    Number.isNaN(openapiVersion) ||\n    openapiVersion < 3 ||\n    openapiVersion >= 4\n  ) {\n    if (document.parsed.swagger) {\n      throw new Error(\"Unsupported Swagger version: 2.x. Use OpenAPI 3.x instead.\");\n    }\n    if (document.parsed.openapi || openapiVersion < 3 || openapiVersion >= 4) {\n      throw new Error(`Unsupported OpenAPI version: ${document.parsed.openapi}`);\n    }\n    throw new Error(\"Unsupported schema format, expected `openapi: 3.x`\");\n  }\n\n  // 2. lint\n  const redocLintT = performance.now();\n  const problems = await lintDocument({\n    document,\n    config: options.redoc.styleguide,\n    externalRefResolver: resolver,\n  });\n  _processProblems(problems, options);\n  debug(\"Linted schema\", \"lint\", performance.now() - redocLintT);\n\n  // 3. bundle\n  const redocBundleT = performance.now();\n  const bundled = await bundle({\n    config: options.redoc,\n    dereference: false,\n    doc: document,\n  });\n  _processProblems(bundled.problems, options);\n  debug(\"Bundled schema\", \"bundle\", performance.now() - redocBundleT);\n\n  return bundled.bundle.parsed;\n}\n"],"names":["Readable","fileURLToPath","Source","parseJson","makeDocumentFromString","error","warn","performance","debug","BaseResolver","lintDocument","bundle"],"mappings":"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"}