{"version":3,"file":"parameters-array.mjs","sources":["../../src/transform/parameters-array.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, oapiRef, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef } from \"../lib/utils.js\";\nimport type { ParameterObject, ReferenceObject, TransformNodeOptions } from \"../types.js\";\nimport transformParameterObject from \"./parameter-object.js\";\n\n// Regex to match path parameters in URL\nconst PATH_PARAM_RE = /\\{([^}]+)\\}/g;\n\n/**\n * Create a synthetic path parameter object from a parameter name\n */\nfunction createPathParameter(paramName: string): ParameterObject {\n  return {\n    name: paramName,\n    in: \"path\",\n    required: true,\n    schema: { type: \"string\" },\n  };\n}\n\n/**\n * Extract path parameters from a URL\n */\nfunction extractPathParamsFromUrl(path: string): ParameterObject[] {\n  const params: ParameterObject[] = [];\n  const matches = path.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      const paramName = match.slice(1, -1);\n      params.push(createPathParameter(paramName));\n    }\n  }\n  return params;\n}\n\n/**\n * Synthetic type. Array of (ParameterObject | ReferenceObject)s found in OperationObject and PathItemObject.\n */\nexport function transformParametersArray(\n  parametersArray: (ParameterObject | ReferenceObject)[],\n  options: TransformNodeOptions,\n): ts.TypeElement[] {\n  const type: ts.TypeElement[] = [];\n\n  // Create a working copy of parameters array\n  const workingParameters = [...parametersArray];\n\n  // Generate path parameters if enabled\n  if (options.ctx.generatePathParams && options.path) {\n    const pathString = Array.isArray(options.path) ? options.path[0] : options.path;\n    if (typeof pathString === \"string\") {\n      const pathParams = extractPathParamsFromUrl(pathString);\n      // Only add path parameters that aren't already defined\n      for (const param of pathParams) {\n        const exists = workingParameters.some((p) => {\n          const resolved = \"$ref\" in p ? options.ctx.resolve<ParameterObject>(p.$ref) : p;\n          return resolved?.in === \"path\" && resolved?.name === param.name;\n        });\n        if (!exists) {\n          workingParameters.push(param);\n        }\n      }\n    }\n  }\n\n  // parameters\n  const paramType: ts.TypeElement[] = [];\n  for (const paramIn of [\"query\", \"header\", \"path\", \"cookie\"] as ParameterObject[\"in\"][]) {\n    const paramLocType: ts.TypeElement[] = [];\n    let operationParameters = workingParameters.map((param) => ({\n      original: param,\n      resolved: \"$ref\" in param ? options.ctx.resolve<ParameterObject>(param.$ref) : param,\n    }));\n\n    // this is the only array type in the spec, so we have to one-off sort here\n    if (options.ctx.alphabetize) {\n      operationParameters.sort((a, b) => (a.resolved?.name ?? \"\").localeCompare(b.resolved?.name ?? \"\"));\n    }\n    if (options.ctx.excludeDeprecated) {\n      operationParameters = operationParameters.filter(\n        ({ resolved }) => !resolved?.deprecated && !resolved?.schema?.deprecated,\n      );\n    }\n    for (const { original, resolved } of operationParameters) {\n      if (resolved?.in !== paramIn) {\n        continue;\n      }\n      let optional: ts.QuestionToken | undefined = undefined;\n      if (paramIn !== \"path\" && !(resolved as ParameterObject).required) {\n        optional = QUESTION_TOKEN;\n      }\n      const subType =\n        \"$ref\" in original\n          ? oapiRef(original.$ref, resolved)\n          : transformParameterObject(resolved as ParameterObject, {\n              ...options,\n              path: createRef([options.path, \"parameters\", resolved.in, resolved.name]),\n            });\n      const property = ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(resolved?.name),\n        /* questionToken */ optional,\n        /* type          */ subType,\n      );\n      addJSDocComment(resolved, property);\n      paramLocType.push(property);\n    }\n    const allOptional = paramLocType.every((node) => !!node.questionToken);\n    paramType.push(\n      ts.factory.createPropertySignature(\n        /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n        /* name          */ tsPropertyIndex(paramIn),\n        /* questionToken */ allOptional || !paramLocType.length ? QUESTION_TOKEN : undefined,\n        /* type          */ paramLocType.length ? ts.factory.createTypeLiteralNode(paramLocType) : NEVER,\n      ),\n    );\n  }\n  type.push(\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"parameters\"),\n      /* questionToken */ !paramType.length ? QUESTION_TOKEN : undefined,\n      /* type          */ paramType.length ? ts.factory.createTypeLiteralNode(paramType) : NEVER,\n    ),\n  );\n\n  return type;\n}\n"],"names":[],"mappings":"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"}